<script>
(function(){
  function ready(fn){ document.readyState!='loading'? fn(): document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    const WRAP = document.createElement('div');
    WRAP.className = 'minesweeper-embed';
    document.body.appendChild(WRAP);

    const style = document.createElement('style');
    style.textContent = `
      .minesweeper-embed{ display:grid; gap:.5rem; font-family:"MS Sans Serif", Tahoma, sans-serif; }
      .minesweeper-embed .panel{ display:flex; align-items:center; justify-content:space-between; gap:.75rem; }
      .minesweeper-embed .lcd{ background:#000; color:#00ff00; font-weight:700; font-family:"Lucida Console", monospace; padding:2px 8px; min-width:66px; text-align:right; }
      .minesweeper-embed .btn{ padding:4px 10px; font-weight:700; cursor:pointer; background:transparent; border:1px solid transparent; }
      .minesweeper-embed .board{ display:grid; gap:2px; }
      .minesweeper-embed .cell{ width:28px; height:28px; display:grid; place-items:center; font-weight:700; font-size:14px; user-select:none; background:#c0c0c0; position:relative; }
      .minesweeper-embed .cell.revealed{ background:#bdbdbd; }
      .minesweeper-embed .cell.dead{ background:#e0e0e0; color:#a0a0a0; cursor:default; }
      .minesweeper-embed .cell.flag::after{ content:"⚑"; font-size:16px; color:#ff0000; }
      .minesweeper-embed .cell.mine::after{ content:"●"; color:#000; font-size:14px; }
      .minesweeper-embed .n1{ color:#0000ff } .minesweeper-embed .n2{ color:#00a000 } .minesweeper-embed .n3{ color:#ff0000 } .minesweeper-embed .n4{ color:#000080 }
      .minesweeper-embed .n5{ color:#800080 } .minesweeper-embed .n6{ color:#008080 } .minesweeper-embed .n7{ color:#000 } .minesweeper-embed .n8{ color:#7f7f7f }
      .minesweeper-embed .foot{ display:flex; flex-wrap:wrap; align-items:center; gap:.5rem; justify-content:space-between; }
      @media (max-width:420px){ .minesweeper-embed .cell{ width:26px; height:26px; } }
    `;
    document.head.appendChild(style);

    WRAP.innerHTML = `
      <div class="panel">
        <div class="lcd" id="mineCount">010</div>
        <button class="btn" id="resetBtn" title="Restart">:‑)</button>
        <div class="lcd" id="timer">000</div>
      </div>
      <div class="board" id="board"></div>
      <div class="foot">
        <div>
          <strong>Preset:</strong>
          <button class="btn" data-preset="easy">Easy</button>
          <button class="btn" data-preset="med">Medium</button>
          <button class="btn" data-preset="hard">Hard</button>
        </div>
        <div class="lcd" id="status">READY</div>
      </div>`;

    const presets = { easy:{rows:9, cols:9, mines:10}, med:{rows:16, cols:16, mines:40}, hard:{rows:16, cols:30, mines:99} };
    let ROWS=9, COLS=9, MINES=10;
    const boardEl = WRAP.querySelector('#board');
    const mineCountEl = WRAP.querySelector('#mineCount');
    const timerEl = WRAP.querySelector('#timer');
    const resetBtn = WRAP.querySelector('#resetBtn');
    const statusEl = WRAP.querySelector('#status');

    let grid=[], started=false, gameOver=false, flags=0, revealed=0, t=0, tHandle=null;

    const z = n => n.toString().padStart(3,'0');
    const clamp = (v,min,max) => Math.max(min, Math.min(max,v));
    const inBounds = (r,c) => r>=0 && r<ROWS && c>=0 && c<COLS;
    function eachNeighbor(r,c,fn){ for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){ if(!dr && !dc) continue; const nr=r+dr, nc=c+dc; if(inBounds(nr,nc)) fn(nr,nc); } }

    function build(){
      boardEl.innerHTML='';
      grid = Array.from({length:ROWS},(_,r)=> Array.from({length:COLS},(_,c)=>({r,c,mine:false,n:0,revealed:false,flagged:false,el:null})))
      boardEl.style.gridTemplateColumns = `repeat(${COLS}, 28px)`;
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        const cell = grid[r][c];
        const d = document.createElement('button');
        d.type='button';
        d.className='cell';
        cell.el=d; boardEl.appendChild(d);
        d.addEventListener('click', (e)=>{ e.stopPropagation(); if(e.shiftKey) { toggleFlag(cell); } else { leftClick(cell); } });
        d.addEventListener('dblclick', (e)=>{ e.stopPropagation(); leftClick(cell); });
        d.addEventListener('contextmenu', (e)=>{ e.preventDefault(); e.stopPropagation(); toggleFlag(cell); });
        d.addEventListener('auxclick', (e)=>{ if(e.button===1){ e.preventDefault(); leftClick(cell); } });
        let pressTimer=null; d.addEventListener('touchstart', ()=>{ pressTimer=setTimeout(()=> toggleFlag(cell), 350); });
        d.addEventListener('touchend', ()=> clearTimeout(pressTimer));
      }
      flags=0; revealed=0; started=false; gameOver=false; t=0; timerEl.textContent='000';
      mineCountEl.textContent=z(MINES-flags); statusEl.textContent='READY'; resetBtn.textContent=':‑)';
    }

    function placeMines(safeR,safeC){
      let placed=0; while(placed<MINES){
        const r=Math.floor(Math.random()*ROWS), c=Math.floor(Math.random()*COLS);
        if(grid[r][c].mine) continue;
        if(Math.abs(r-safeR)<=1 && Math.abs(c-safeC)<=1) continue;
        grid[r][c].mine=true; placed++;
      }
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(!grid[r][c].mine){
        let n=0; eachNeighbor(r,c,(nr,nc)=>{ if(grid[nr][nc].mine) n++; }); grid[r][c].n=n;
      }
    }

    function startTimer(){ if(tHandle) return; tHandle=setInterval(()=>{ t=clamp(t+1,0,999); timerEl.textContent=z(t); },1000); }
    function stopTimer(){ clearInterval(tHandle); tHandle=null; }

    function leftClick(cell){
      if (gameOver) return;
      if (!started){ started=true; placeMines(cell.r,cell.c); startTimer(); }
      if (!cell.revealed && !cell.flagged){ reveal(cell); return; }
      if (cell.revealed && cell.n>0){
        let flagged=0; const toOpen=[];
        eachNeighbor(cell.r,cell.c,(nr,nc)=>{ const nb=grid[nr][nc]; if(nb.flagged) flagged++; else if(!nb.revealed) toOpen.push(nb); });
        if (flagged === cell.n){
          for (const nb of toOpen){ if (nb.mine){ nb.el.classList.add('revealed','mine'); lose(); return; } }
          for (const nb of toOpen){ reveal(nb); }
        }
      }
    }

    function toggleFlag(cell){ if(gameOver||cell.revealed) return; cell.flagged=!cell.flagged; flags+=cell.flagged?1:-1; cell.el.classList.toggle('flag',cell.flagged); mineCountEl.textContent=z(MINES-flags); }

    function reveal(cell){
      if(cell.revealed||cell.flagged) return; cell.revealed=true; revealed++; cell.el.classList.add('revealed');
      if(cell.mine){ cell.el.classList.add('mine'); lose(); return; }
      if(cell.n>0){ cell.el.textContent=cell.n; cell.el.classList.add('n'+cell.n); }
      else eachNeighbor(cell.r,cell.c,(nr,nc)=> reveal(grid[nr][nc]));
      // Mark surrounding dead squares
      if(cell.revealed && cell.n>0){ eachNeighbor(cell.r,cell.c,(nr,nc)=>{ const nb=grid[nr][nc]; if(!nb.mine && !nb.flagged && !nb.revealed){ nb.el.classList.add('dead'); } }); }
      checkWin();
    }

    function showAllMines(){ for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const cell=grid[r][c]; if(cell.mine){ cell.el.classList.add('revealed','mine'); } } }
    function lose(){ gameOver=true; stopTimer(); showAllMines(); resetBtn.textContent='×_×'; statusEl.textContent='BOOM'; }
    function checkWin(){ if(revealed >= ROWS*COLS - MINES){ gameOver=true; stopTimer(); resetBtn.textContent='^_^'; statusEl.textContent='CLEARED'; } }

    function reset(p){ if(p){ ROWS=p.rows; COLS=p.cols; MINES=p.mines; } build(); }

    resetBtn.addEventListener('click', ()=> reset());
    WRAP.querySelectorAll('[data-preset]').forEach(b=> b.addEventListener('click', ()=> reset(presets[b.dataset.preset])));

    build();
  });
})();
</script>
